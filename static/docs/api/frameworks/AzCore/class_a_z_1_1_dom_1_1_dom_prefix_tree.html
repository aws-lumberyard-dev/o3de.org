<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine AzCore API Reference: AZ::Dom::DomPrefixTree&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">2107.1 (Developer Preview)</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><b>Dom</b></li><li class="navelem"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_a_z_1_1_dom_1_1_dom_prefix_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::Dom::DomPrefixTree&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A prefix tree that maps DOM paths to some arbitrary value.  
 <a href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#details">More...</a></p>

<p><code>#include &lt;DomPrefixTree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1a44796555e50e975ea3ef4ea228ec05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a1a44796555e50e975ea3ef4ea228ec05">VisitorFunction</a> = <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool(const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;, T &amp;)&gt;</td></tr>
<tr class="separator:a1a44796555e50e975ea3ef4ea228ec05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23831cb6b746554833f1b57f0017705a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23831cb6b746554833f1b57f0017705a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ConstVisitorFunction</b> = <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt; bool(const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;, const T &amp;)&gt;</td></tr>
<tr class="separator:a23831cb6b746554833f1b57f0017705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af41bbd549612445d63f53324d9201d5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41bbd549612445d63f53324d9201d5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DomPrefixTree</b> (const <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;)=default</td></tr>
<tr class="separator:af41bbd549612445d63f53324d9201d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c41703e5aa00ef6cadd5ceb9ad042"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae63c41703e5aa00ef6cadd5ceb9ad042"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DomPrefixTree</b> (<a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ae63c41703e5aa00ef6cadd5ceb9ad042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf43e69a348ec42d06757f76cfd2678"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bf43e69a348ec42d06757f76cfd2678"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DomPrefixTree</b> (AZStd::initializer_list&lt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a>, T &gt;&gt; init)</td></tr>
<tr class="separator:a3bf43e69a348ec42d06757f76cfd2678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f9f800f2c53e7ac202800e0513da5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a07f9f800f2c53e7ac202800e0513da5d"></a>
template&lt;class Range , class  = AZStd::enable_if_t&lt;RangeConvertibleToPrefixTree&lt;Range, T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a07f9f800f2c53e7ac202800e0513da5d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DomPrefixTree</b> (Range &amp;&amp;range)</td></tr>
<tr class="separator:a07f9f800f2c53e7ac202800e0513da5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefb56036cd79aae0c760b4e067de66c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abefb56036cd79aae0c760b4e067de66c"></a>
<a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;)=default</td></tr>
<tr class="separator:abefb56036cd79aae0c760b4e067de66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912e81b661f85a2c70b7d7d801c65087"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a912e81b661f85a2c70b7d7d801c65087"></a>
<a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a912e81b661f85a2c70b7d7d801c65087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1bafe1c99c87caa478865103d9df3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb1bafe1c99c87caa478865103d9df3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#afb1bafe1c99c87caa478865103d9df3a">VisitPath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, const <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a1a44796555e50e975ea3ef4ea228ec05">VisitorFunction</a> &amp;visitor, PrefixTreeTraversalFlags flags=DefaultTraversalFlags)</td></tr>
<tr class="memdesc:afb1bafe1c99c87caa478865103d9df3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits a path and calls a visitor for each matching path and value. <br/></td></tr>
<tr class="separator:afb1bafe1c99c87caa478865103d9df3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8290b077f69838880ea08437bebd0d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8290b077f69838880ea08437bebd0d45"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisitPath</b> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, const <a class="el" href="class_a_z_std_1_1function.html">ConstVisitorFunction</a> &amp;visitor, PrefixTreeTraversalFlags flags=DefaultTraversalFlags) const </td></tr>
<tr class="separator:a8290b077f69838880ea08437bebd0d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb1c9e502a4d75be16a853102253294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eb1c9e502a4d75be16a853102253294"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a0eb1c9e502a4d75be16a853102253294">ValueAtPath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, PrefixTreeMatch match)</td></tr>
<tr class="memdesc:a0eb1c9e502a4d75be16a853102253294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits a path and returns the most specific matching value, or null if none was found. <br/></td></tr>
<tr class="separator:a0eb1c9e502a4d75be16a853102253294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d691f4cf6ca59a5c4869d912790e629"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a5d691f4cf6ca59a5c4869d912790e629">ValueAtPath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, PrefixTreeMatch match) const </td></tr>
<tr class="separator:a5d691f4cf6ca59a5c4869d912790e629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe50e861866669d1b024fb7a2a7e82b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe50e861866669d1b024fb7a2a7e82b5"></a>
template&lt;class Deduced &gt; </td></tr>
<tr class="memitem:abe50e861866669d1b024fb7a2a7e82b5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#abe50e861866669d1b024fb7a2a7e82b5">ValueAtPathOrDefault</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, Deduced &amp;&amp;defaultValue, PrefixTreeMatch match) const </td></tr>
<tr class="memdesc:abe50e861866669d1b024fb7a2a7e82b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits a path and returns the most specific matching value or some default value. <br/></td></tr>
<tr class="separator:abe50e861866669d1b024fb7a2a7e82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb5558c86a8168758557ff209cd77f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb5558c86a8168758557ff209cd77f4"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a7eb5558c86a8168758557ff209cd77f4">operator[]</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a7eb5558c86a8168758557ff209cd77f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a value at the given exact path. <br/></td></tr>
<tr class="separator:a7eb5558c86a8168758557ff209cd77f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e1bdeadf1732d9bd4378efec98c651"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a07e1bdeadf1732d9bd4378efec98c651">operator[]</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path) const </td></tr>
<tr class="separator:a07e1bdeadf1732d9bd4378efec98c651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd26fdfeee5ccda150d8db1c101d926"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7cd26fdfeee5ccda150d8db1c101d926"></a>
template&lt;class Deduced &gt; </td></tr>
<tr class="memitem:a7cd26fdfeee5ccda150d8db1c101d926"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a7cd26fdfeee5ccda150d8db1c101d926">SetValue</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, Deduced &amp;&amp;value)</td></tr>
<tr class="memdesc:a7cd26fdfeee5ccda150d8db1c101d926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value stored at path. <br/></td></tr>
<tr class="separator:a7cd26fdfeee5ccda150d8db1c101d926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6611fadb3cc0ce80afd59f5b5494dae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6611fadb3cc0ce80afd59f5b5494dae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#aa6611fadb3cc0ce80afd59f5b5494dae">EraseValue</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, bool removeChildren=false)</td></tr>
<tr class="memdesc:aa6611fadb3cc0ce80afd59f5b5494dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the value stored at path. If removeChildren is true, also removes any values stored at subpaths. <br/></td></tr>
<tr class="separator:aa6611fadb3cc0ce80afd59f5b5494dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0a1ac9aa8f0f295057452017fae675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#abc0a1ac9aa8f0f295057452017fae675">DetachSubTree</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:abc0a1ac9aa8f0f295057452017fae675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa465c335bfade2edd74d7b27c2bb76ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#aa465c335bfade2edd74d7b27c2bb76ce">OverwritePath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a> &amp;&amp;subtree, bool shouldCreateNodes=true)</td></tr>
<tr class="separator:aa465c335bfade2edd74d7b27c2bb76ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a24b2f3ff83a3e6effa61f857ab598c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a24b2f3ff83a3e6effa61f857ab598c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a4a24b2f3ff83a3e6effa61f857ab598c">Clear</a> ()</td></tr>
<tr class="memdesc:a4a24b2f3ff83a3e6effa61f857ab598c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries from this tree. <br/></td></tr>
<tr class="separator:a4a24b2f3ff83a3e6effa61f857ab598c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e7fb1236f6ddcc0e19797eb3b4fe02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0e7fb1236f6ddcc0e19797eb3b4fe02"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#ad0e7fb1236f6ddcc0e19797eb3b4fe02">IsEmpty</a> () const </td></tr>
<tr class="memdesc:ad0e7fb1236f6ddcc0e19797eb3b4fe02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the root node is empty. <br/></td></tr>
<tr class="separator:ad0e7fb1236f6ddcc0e19797eb3b4fe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a291274d12f66c1b09b74368a175f3cdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291274d12f66c1b09b74368a175f3cdc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a291274d12f66c1b09b74368a175f3cdc">DomPrefixTree</a> (<a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> &amp;&amp;node)</td></tr>
<tr class="memdesc:a291274d12f66c1b09b74368a175f3cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since <a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> is an internal private struct in this class, this constructor that uses <a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> is also private. <br/></td></tr>
<tr class="separator:a291274d12f66c1b09b74368a175f3cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa554b2ea9ce14b7e65cc53fd85e0d61d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa554b2ea9ce14b7e65cc53fd85e0d61d"></a>
<a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeForPath</b> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:aa554b2ea9ce14b7e65cc53fd85e0d61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a6894faef99fd2e075571c9c55de11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a6894faef99fd2e075571c9c55de11"></a>
const <a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetNodeForPath</b> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path) const </td></tr>
<tr class="separator:ab8a6894faef99fd2e075571c9c55de11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac811e3148adef4aa5ce806c25635e0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#ac811e3148adef4aa5ce806c25635e0ac">DetachNodeAtPath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ac811e3148adef4aa5ce806c25635e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfb92f621462cfc018b11b565a409a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a9dfb92f621462cfc018b11b565a409a6">OverwritePath</a> (const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;path, <a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> &amp;&amp;newNode, bool shouldCreateNodes=true)</td></tr>
<tr class="separator:a9dfb92f621462cfc018b11b565a409a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acf4027ad0a6471a034e9ed098b7bf2ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf4027ad0a6471a034e9ed098b7bf2ca"></a>
<a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_rootNode</b></td></tr>
<tr class="separator:acf4027ad0a6471a034e9ed098b7bf2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class AZ::Dom::DomPrefixTree&lt; T &gt;</h3>

<p>A prefix tree that maps DOM paths to some arbitrary value. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1a44796555e50e975ea3ef4ea228ec05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::<a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a1a44796555e50e975ea3ef4ea228ec05">VisitorFunction</a> =  <a class="el" href="class_a_z_std_1_1function.html">AZStd::function</a>&lt;bool(const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a>&amp;, T&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VisitorFunctions are callbacks invoked by VisitPath. VisitorFunction is provided with the path to a given value and a reference to the associated value. The callback returns a boolean value indicating whether or not the visit operation should continue running. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac811e3148adef4aa5ce806c25635e0ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::DetachNodeAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detaches the node that matches the provided path. The detach operation removes the node and its children from the existing tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path at which the node should be detached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> that is detached. </dd></dl>

</div>
</div>
<a class="anchor" id="abc0a1ac9aa8f0f295057452017fae675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a>&lt; T &gt; <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::DetachSubTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detaches a sub tree whose root node matches the provided path. The detach operation removes the node and its children from the existing tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path which corresponds to the root node of the subtree to be detached. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html" title="A prefix tree that maps DOM paths to some arbitrary value. ">DomPrefixTree</a> that is detached. </dd></dl>

</div>
</div>
<a class="anchor" id="a07e1bdeadf1732d9bd4378efec98c651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a value for a given exact path. </p>
<dl class="section warning"><dt>Warning</dt><dd>This is an unsafe operation for entries that are not already present in the tree. Prefer ValueAtPath or ValueAtPathOrDefault in those cases. </dd></dl>

</div>
</div>
<a class="anchor" id="aa465c335bfade2edd74d7b27c2bb76ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::OverwritePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">DomPrefixTree</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCreateNodes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwrites the subtree at the path and replaces it with the given subtree. Old node and its children at the path would be destroyed. The new subtree will be moved to the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path which corresponds to the root node to which the subtree would be overwritten. </td></tr>
    <tr><td class="paramname">subtree</td><td>The subtree to move to the provided path. </td></tr>
    <tr><td class="paramname">shouldCreateNodes</td><td>Create nodes for the provided path if they are missing. Default to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the subtree was overwritten successfully, false if shouldCreateNodes is off and no target path exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfb92f621462cfc018b11b565a409a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::OverwritePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_dom_1_1_dom_prefix_tree_1_1_node.html">Node</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>newNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCreateNodes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overwrites the node at the path and replaces it with the given node. Old node and its children at the path would be destroyed. New nodes will be moved to the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path which corresponds to the root node to be overwritten. </td></tr>
    <tr><td class="paramname">newNode</td><td>The new node to move to the provided path. </td></tr>
    <tr><td class="paramname">shouldCreateNodes</td><td>Create nodes for the provided path if they are missing. Default to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node was overwritten successfully, false if shouldCreateNodes is off and no target path exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d691f4cf6ca59a5c4869d912790e629"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html">AZ::Dom::DomPrefixTree</a>&lt; T &gt;::ValueAtPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_1_1_dom_1_1_path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrefixTreeMatch&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_a_z_1_1_dom_1_1_dom_prefix_tree.html#a0eb1c9e502a4d75be16a853102253294" title="Visits a path and returns the most specific matching value, or null if none was found. ">ValueAtPath</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/DOM/DomPrefixTree.h</li>
<li>Code/Framework/AzCore/AzCore/DOM/DomPrefixTree.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 13 2023 22:56:59 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
