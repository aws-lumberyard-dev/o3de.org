<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine AzCore API Reference: AZStd::rbtree&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">2107.1 (Developer Preview)</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z_std.html">AZStd</a></li><li class="navelem"><a class="el" href="class_a_z_std_1_1rbtree.html">rbtree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_a_z_std_1_1rbtree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZStd::rbtree&lt; Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;rbtree.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a43a394625797a79d50db1b3d3b77cae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43a394625797a79d50db1b3d3b77cae8"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:a43a394625797a79d50db1b3d3b77cae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71109d094df693500fac8cfbaf2451b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71109d094df693500fac8cfbaf2451b9"></a>
typedef Traits::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a71109d094df693500fac8cfbaf2451b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916253e87a42f01686b55b74346c4652"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a916253e87a42f01686b55b74346c4652"></a>
typedef Traits::key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:a916253e87a42f01686b55b74346c4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d4494a15250e1c22b4e757f5760110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77d4494a15250e1c22b4e757f5760110"></a>
typedef Traits::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a77d4494a15250e1c22b4e757f5760110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d9bb514c883b293f160b074d2c7ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66d9bb514c883b293f160b074d2c7ed9"></a>
typedef allocator_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a66d9bb514c883b293f160b074d2c7ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01947cdc73e7a0c06740bdb5620b2a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab01947cdc73e7a0c06740bdb5620b2a5"></a>
typedef <br class="typebreak"/>
allocator_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:ab01947cdc73e7a0c06740bdb5620b2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae672c9b7c6f4f77350abc4af1b6661c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae672c9b7c6f4f77350abc4af1b6661c8"></a>
typedef Traits::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:ae672c9b7c6f4f77350abc4af1b6661c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889921dfdb830ff5843ac539e1b0ddc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889921dfdb830ff5843ac539e1b0ddc6"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a889921dfdb830ff5843ac539e1b0ddc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91abc6163f55fa25e568c49615004252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91abc6163f55fa25e568c49615004252"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:a91abc6163f55fa25e568c49615004252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0bb109089819e86ffe222f604d2b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b0bb109089819e86ffe222f604d2b3"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a82b0bb109089819e86ffe222f604d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8fa6b00627e4676ca67417639e02fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8fa6b00627e4676ca67417639e02fd"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a4e8fa6b00627e4676ca67417639e02fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d93ca053ba0b6be9fc36c8816671d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab61d93ca053ba0b6be9fc36c8816671d"></a>
typedef <br class="typebreak"/>
<a class="el" href="namespace_a_z_std.html#a51da0cadfe49abd2822249512fa31fcb">AZStd::bidirectional_iterator_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_category</b></td></tr>
<tr class="separator:ab61d93ca053ba0b6be9fc36c8816671d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fd4f3a88f58debdbc7f29649466e8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0fd4f3a88f58debdbc7f29649466e8a"></a>
typedef Internal::rbtree_node<br class="typebreak"/>
&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_type</b></td></tr>
<tr class="separator:aa0fd4f3a88f58debdbc7f29649466e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d77955af8f5f024713d30a3fbc20d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66d77955af8f5f024713d30a3fbc20d5"></a>
typedef node_type *&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr_type</b></td></tr>
<tr class="separator:a66d77955af8f5f024713d30a3fbc20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4032f0cc16ce2d3d7ca42cd2bdeba9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c4032f0cc16ce2d3d7ca42cd2bdeba9"></a>
typedef const node_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr_type</b></td></tr>
<tr class="separator:a5c4032f0cc16ce2d3d7ca42cd2bdeba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6529bf6f03f8e6ef6a938ab9f8f14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6529bf6f03f8e6ef6a938ab9f8f14e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">rbtree_const_iterator</a><br class="typebreak"/>
&lt; typename Traits::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator_impl</b></td></tr>
<tr class="separator:a2a6529bf6f03f8e6ef6a938ab9f8f14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5266865d5d3f502f4b670fe30bdea68e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5266865d5d3f502f4b670fe30bdea68e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">rbtree_iterator</a><br class="typebreak"/>
&lt; typename Traits::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator_impl</b></td></tr>
<tr class="separator:a5266865d5d3f502f4b670fe30bdea68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9138fa5c2d1aa3aecc42422b57137e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e9138fa5c2d1aa3aecc42422b57137e"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:a1e9138fa5c2d1aa3aecc42422b57137e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc96f9ccb90dd95705e9e58cbfc42856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc96f9ccb90dd95705e9e58cbfc42856"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:adc96f9ccb90dd95705e9e58cbfc42856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de05a76c3dd6eb56c1999b63efa270b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de05a76c3dd6eb56c1999b63efa270b"></a>
typedef <br class="typebreak"/>
AZStd::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a4de05a76c3dd6eb56c1999b63efa270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588620fc55b40dd0f18aeda724a3054d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a588620fc55b40dd0f18aeda724a3054d"></a>
typedef <br class="typebreak"/>
AZStd::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a588620fc55b40dd0f18aeda724a3054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8375a43478820ae31bb896fce4204f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8375a43478820ae31bb896fce4204f"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree__node__destructor.html">rbtree_node_destructor</a><br class="typebreak"/>
&lt; allocator_type, node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_deleter</b></td></tr>
<tr class="separator:aff8375a43478820ae31bb896fce4204f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6123406df99016d300e1144752ec05af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6123406df99016d300e1144752ec05af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const key_equal &amp;keyEq)</td></tr>
<tr class="separator:a6123406df99016d300e1144752ec05af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73131bfa75f13baa311eec5654fcc91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab73131bfa75f13baa311eec5654fcc91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:ab73131bfa75f13baa311eec5654fcc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154a36a52c9a3b8a30edda3f3ae40434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a154a36a52c9a3b8a30edda3f3ae40434"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const key_equal &amp;keyEq, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a154a36a52c9a3b8a30edda3f3ae40434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793f7c4c16139f38c8577d430fc661d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793f7c4c16139f38c8577d430fc661d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a793f7c4c16139f38c8577d430fc661d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c4bea61140df1d6a3c4c197ef900c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7c4bea61140df1d6a3c4c197ef900c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:ac7c4bea61140df1d6a3c4c197ef900c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0608d14ad524657a69e3a0c49a6413e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0608d14ad524657a69e3a0c49a6413e"></a>
<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:ab0608d14ad524657a69e3a0c49a6413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371f5593755f387781db830d74ca06c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7371f5593755f387781db830d74ca06c"></a>
AZ_FORCE_INLINE key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_comp</b> () const </td></tr>
<tr class="separator:a7371f5593755f387781db830d74ca06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad372e2261f4919aed05df94870fad0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaad372e2261f4919aed05df94870fad0"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:aaad372e2261f4919aed05df94870fad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98db2837bbd8240d54dac046de7545ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98db2837bbd8240d54dac046de7545ce"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:a98db2837bbd8240d54dac046de7545ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b63300efdea28e166f0cd5b2f9e45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a9b63300efdea28e166f0cd5b2f9e45"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a4a9b63300efdea28e166f0cd5b2f9e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e750373f13be5841fba577b8bf9f8cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e750373f13be5841fba577b8bf9f8cd"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a5e750373f13be5841fba577b8bf9f8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2816469503fd396e65594f215079cd29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2816469503fd396e65594f215079cd29"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a2816469503fd396e65594f215079cd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff8dad9d32164b20a20183ae962bb53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff8dad9d32164b20a20183ae962bb53"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const </td></tr>
<tr class="separator:a0ff8dad9d32164b20a20183ae962bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cee3bf31ffbe9e7364ac5613461bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2cee3bf31ffbe9e7364ac5613461bfb"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:ae2cee3bf31ffbe9e7364ac5613461bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117feb17a8dd58c87604c8179a10aa05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a117feb17a8dd58c87604c8179a10aa05"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const </td></tr>
<tr class="separator:a117feb17a8dd58c87604c8179a10aa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab201e66f72627caf793d9c1a94767459"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab201e66f72627caf793d9c1a94767459"></a>
AZ_FORCE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const </td></tr>
<tr class="separator:ab201e66f72627caf793d9c1a94767459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3791d2e49e520d688a7b6535b8d28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a3791d2e49e520d688a7b6535b8d28"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const </td></tr>
<tr class="separator:a74a3791d2e49e520d688a7b6535b8d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323702ed60bbb6138369f0182428facf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a323702ed60bbb6138369f0182428facf"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const </td></tr>
<tr class="separator:a323702ed60bbb6138369f0182428facf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a50a0f97b5e2f21ad8110ba0ea09935"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a50a0f97b5e2f21ad8110ba0ea09935"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a8a50a0f97b5e2f21ad8110ba0ea09935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23498503b1f831c801c39aeeb630e902"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23498503b1f831c801c39aeeb630e902"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rbtree</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs, const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a23498503b1f831c801c39aeeb630e902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962b6a8bce1538ff5b8e70bd4b4b144f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a962b6a8bce1538ff5b8e70bd4b4b144f"></a>
<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a962b6a8bce1538ff5b8e70bd4b4b144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af028fedfa1e24d361be00b52706c76bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af028fedfa1e24d361be00b52706c76bf"></a>
<a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:af028fedfa1e24d361be00b52706c76bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8d46d2e11ab3d7d0cacb9be2f791a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f8d46d2e11ab3d7d0cacb9be2f791a"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, value_type &amp;&amp;value)</td></tr>
<tr class="separator:a41f8d46d2e11ab3d7d0cacb9be2f791a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c1a7faee71372f6b445934d95b0f87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c1a7faee71372f6b445934d95b0f87"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:a78c1a7faee71372f6b445934d95b0f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caf3f215bf42c955c8287d011c41648"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3caf3f215bf42c955c8287d011c41648"></a>
template&lt;class... InputArguments&gt; </td></tr>
<tr class="memitem:a3caf3f215bf42c955c8287d011c41648"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_unique</b> (InputArguments &amp;&amp;...arguments)</td></tr>
<tr class="separator:a3caf3f215bf42c955c8287d011c41648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4b57e098f21ea3573ee6b03c8eb497"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d4b57e098f21ea3573ee6b03c8eb497"></a>
template&lt;class... InputArguments&gt; </td></tr>
<tr class="memitem:a0d4b57e098f21ea3573ee6b03c8eb497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, InputArguments &amp;&amp;...arguments)</td></tr>
<tr class="separator:a0d4b57e098f21ea3573ee6b03c8eb497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe898e9a784ec52e28e6e750baee0b9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe898e9a784ec52e28e6e750baee0b9c"></a>
template&lt;class... InputArguments&gt; </td></tr>
<tr class="memitem:abe898e9a784ec52e28e6e750baee0b9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_equal</b> (InputArguments &amp;&amp;...arguments)</td></tr>
<tr class="separator:abe898e9a784ec52e28e6e750baee0b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c76ef257658680c48a95c2f8aec668"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8c76ef257658680c48a95c2f8aec668"></a>
template&lt;class... InputArguments&gt; </td></tr>
<tr class="memitem:ad8c76ef257658680c48a95c2f8aec668"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_equal</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, InputArguments &amp;&amp;...arguments)</td></tr>
<tr class="separator:ad8c76ef257658680c48a95c2f8aec668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82752b44d86b12b74918a16494eb3fa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82752b44d86b12b74918a16494eb3fa9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_a_z_std_1_1rbtree.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a82752b44d86b12b74918a16494eb3fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb5987e1bffccf24fff3a83eebda7bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb5987e1bffccf24fff3a83eebda7bc"></a>
<a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (const value_type &amp;value)</td></tr>
<tr class="separator:a1fb5987e1bffccf24fff3a83eebda7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacfc1bda881f14bb61f9ed5bab5892d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acacfc1bda881f14bb61f9ed5bab5892d"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (const value_type &amp;value)</td></tr>
<tr class="separator:acacfc1bda881f14bb61f9ed5bab5892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613c935a80a037b8021ba15eb98b2f63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a613c935a80a037b8021ba15eb98b2f63"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, const value_type &amp;value)</td></tr>
<tr class="separator:a613c935a80a037b8021ba15eb98b2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daec9a8f9f7350da1d1065aa688867f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2daec9a8f9f7350da1d1065aa688867f"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> insertPos, const value_type &amp;value)</td></tr>
<tr class="separator:a2daec9a8f9f7350da1d1065aa688867f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eada7dec00a61811a84250d3aa3afd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46eada7dec00a61811a84250d3aa3afd"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a46eada7dec00a61811a84250d3aa3afd"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_equal</b> (Iterator first, Iterator last)</td></tr>
<tr class="separator:a46eada7dec00a61811a84250d3aa3afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b89588973ccb7a17b20448228a9474"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86b89588973ccb7a17b20448228a9474"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a86b89588973ccb7a17b20448228a9474"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_unique</b> (Iterator first, Iterator last)</td></tr>
<tr class="separator:a86b89588973ccb7a17b20448228a9474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7892cc1730eb40b2f1884ca4c58cca60"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7892cc1730eb40b2f1884ca4c58cca60"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a7892cc1730eb40b2f1884ca4c58cca60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments)</td></tr>
<tr class="separator:a7892cc1730eb40b2f1884ca4c58cca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f9b105c9d208bf207f0126e6791c00"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01f9b105c9d208bf207f0126e6791c00"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a01f9b105c9d208bf207f0126e6791c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments)</td></tr>
<tr class="separator:a01f9b105c9d208bf207f0126e6791c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memTemplParams" colspan="2"><a class="anchor" id="af19f1cad3a9ce5a4cf3b24211ea74824"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:af19f1cad3a9ce5a4cf3b24211ea74824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c3495f88ccae61a663393fd691da94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a09c3495f88ccae61a663393fd691da94"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a09c3495f88ccae61a663393fd691da94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value)</td></tr>
<tr class="separator:a09c3495f88ccae61a663393fd691da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad679828b56edf29b1afcfabb6b6812a9"><td class="memTemplParams" colspan="2">template&lt;class InsertReturnType , class NodeHandle &gt; </td></tr>
<tr class="memitem:ad679828b56edf29b1afcfabb6b6812a9"><td class="memTemplItemLeft" align="right" valign="top">InsertReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#ad679828b56edf29b1afcfabb6b6812a9">node_handle_insert_unique</a> (NodeHandle &amp;&amp;nodeHandle)</td></tr>
<tr class="separator:ad679828b56edf29b1afcfabb6b6812a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e9ea86f0c99b3c5ee35b0deed62036e"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert_unique</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> hint, NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a0e9ea86f0c99b3c5ee35b0deed62036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03292f2d5c86394b43db5755ec40431f"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a03292f2d5c86394b43db5755ec40431f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a03292f2d5c86394b43db5755ec40431f">node_handle_insert_equal</a> (NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a03292f2d5c86394b43db5755ec40431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b1ccd25b6548d7b2478b535262b885"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7b1ccd25b6548d7b2478b535262b885"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ae7b1ccd25b6548d7b2478b535262b885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert_equal</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> hint, NodeHandle &amp;&amp;nodeHandle) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:ae7b1ccd25b6548d7b2478b535262b885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a60d84597279f45fd4fb59fb2e6adafc5">node_handle_extract</a> (const key_type &amp;key)</td></tr>
<tr class="separator:a60d84597279f45fd4fb59fb2e6adafc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#ac71730ba5e3cac7386ad9c223ebf5209">node_handle_extract</a> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> it)</td></tr>
<tr class="separator:ac71730ba5e3cac7386ad9c223ebf5209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7134a80d7105d4b57da5f5b78eb96d1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7134a80d7105d4b57da5f5b78eb96d1f"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> erasePos)</td></tr>
<tr class="separator:a7134a80d7105d4b57da5f5b78eb96d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376e2d065043ef2baee4f98c41bc817a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a376e2d065043ef2baee4f98c41bc817a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type &amp;key)</td></tr>
<tr class="separator:a376e2d065043ef2baee4f98c41bc817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0857629b3fece39f2c08f625430a82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a0857629b3fece39f2c08f625430a82"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>erase_unique</b> (const key_type &amp;key)</td></tr>
<tr class="separator:a2a0857629b3fece39f2c08f625430a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb4a4f451fa9ba99b6745b6bd5458d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeb4a4f451fa9ba99b6745b6bd5458d1"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> first, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> last)</td></tr>
<tr class="separator:aeeb4a4f451fa9ba99b6745b6bd5458d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77332e998fb1e559110c8a9082fdbd5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77332e998fb1e559110c8a9082fdbd5f"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type *first, const key_type *last)</td></tr>
<tr class="separator:a77332e998fb1e559110c8a9082fdbd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee6a0458afe9cc92be134403a69dd83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee6a0458afe9cc92be134403a69dd83"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a6ee6a0458afe9cc92be134403a69dd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854bec73079c515c9c3ba963b7387d21"><td class="memTemplParams" colspan="2"><a class="anchor" id="a854bec73079c515c9c3ba963b7387d21"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a854bec73079c515c9c3ba963b7387d21"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a854bec73079c515c9c3ba963b7387d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="acf2bc0cac874bb165fafa8fa96e4ae7d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:acf2bc0cac874bb165fafa8fa96e4ae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f45b88a3bf93ff209a8698bae77a14d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, bool &gt;</td></tr>
<tr class="separator:a9f45b88a3bf93ff209a8698bae77a14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaafc0fd5ddd22ba9ad55529a068c40ac"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:aaafc0fd5ddd22ba9ad55529a068c40ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6861fcfe337f7a337dd6291fcf67e00"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:ac6861fcfe337f7a337dd6291fcf67e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62f32ce0f0b7c28ff1888e485bbb5360"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;</td></tr>
<tr class="separator:a62f32ce0f0b7c28ff1888e485bbb5360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d007e6150e70375db25a66c1b38c8f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d007e6150e70375db25a66c1b38c8f1"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a0d007e6150e70375db25a66c1b38c8f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a0d007e6150e70375db25a66c1b38c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1be6e24300f8d13cba08ea7f8bce5418"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, size_type &gt;</td></tr>
<tr class="separator:a1be6e24300f8d13cba08ea7f8bce5418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9c510f9b1bb041c20642f4e31f7a07f7"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a9c510f9b1bb041c20642f4e31f7a07f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3384bd9c98d5e1d6ebb0816e49ca6c8e"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a3384bd9c98d5e1d6ebb0816e49ca6c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59a51fe519f23894fa7c49c4cfcccd44"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range_unique</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a59a51fe519f23894fa7c49c4cfcccd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e30f56fb690ecdba13ab920dda161"><td class="memTemplParams" colspan="2"><a class="anchor" id="a588e30f56fb690ecdba13ab920dda161"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a588e30f56fb690ecdba13ab920dda161"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range_unique</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt; Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>, <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &gt;&gt;</td></tr>
<tr class="separator:a588e30f56fb690ecdba13ab920dda161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeb8805a7c887345d66ce08d5b316d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbeb8805a7c887345d66ce08d5b316d7"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:acbeb8805a7c887345d66ce08d5b316d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;</td></tr>
<tr class="separator:acbeb8805a7c887345d66ce08d5b316d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca46db8018b18d2eaaed6ee36d4026a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca46db8018b18d2eaaed6ee36d4026a5"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:aca46db8018b18d2eaaed6ee36d4026a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:aca46db8018b18d2eaaed6ee36d4026a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e629e0a9a5c20fda1af9f5198cf603"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;</td></tr>
<tr class="separator:a55e629e0a9a5c20fda1af9f5198cf603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49fa1b153ad4d9a552918c7dad5c789e"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_unique</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> hint, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td></tr>
<tr class="separator:a49fa1b153ad4d9a552918c7dad5c789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="ListExtensions"></a></p>
</div></td></tr>
<tr class="memitem:af9ca84df11524d421fa25466b0cf3330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9ca84df11524d421fa25466b0cf3330"></a>
allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:af9ca84df11524d421fa25466b0cf3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a7c1fab026bd17d2440b9d1efd2d73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a7c1fab026bd17d2440b9d1efd2d73"></a>
const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const </td></tr>
<tr class="separator:a81a7c1fab026bd17d2440b9d1efd2d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9eaa430cab081363a3f76ebc536955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc9eaa430cab081363a3f76ebc536955"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#abc9eaa430cab081363a3f76ebc536955">set_allocator</a> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="memdesc:abc9eaa430cab081363a3f76ebc536955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the vector allocator. If different than then current all elements will be reallocated. <br/></td></tr>
<tr class="separator:abc9eaa430cab081363a3f76ebc536955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac35db8bf791f85f644ca5aa4e511c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ac35db8bf791f85f644ca5aa4e511c7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> () const </td></tr>
<tr class="separator:a2ac35db8bf791f85f644ca5aa4e511c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967a4d9c4905b38a0773490a7e1c7535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967a4d9c4905b38a0773490a7e1c7535"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#a967a4d9c4905b38a0773490a7e1c7535">validate_iterator</a> (const <a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> &amp;iter) const </td></tr>
<tr class="memdesc:a967a4d9c4905b38a0773490a7e1c7535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an iter iterator. Returns a combination of <a class="el" href="namespace_a_z_std.html#a77fc989e737c35ee90f2b8ef6f5e9b9c">iterator_status_flag</a>. <br/></td></tr>
<tr class="separator:a967a4d9c4905b38a0773490a7e1c7535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf39244f67aa07d6a2f9de501e6cbda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaf39244f67aa07d6a2f9de501e6cbda"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>validate_iterator</b> (const <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a> &amp;iter) const </td></tr>
<tr class="separator:adaf39244f67aa07d6a2f9de501e6cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a82f156a68dfe1b7553310c7b2e862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1rbtree.html#aa2a82f156a68dfe1b7553310c7b2e862">leak_and_reset</a> ()</td></tr>
<tr class="separator:aa2a82f156a68dfe1b7553310c7b2e862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a3f47b700cc4d99ebfe7fbc3a0bf60bbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f47b700cc4d99ebfe7fbc3a0bf60bbd"></a>
typedef <br class="typebreak"/>
Internal::rbtree_node_base *&#160;</td><td class="memItemRight" valign="bottom"><b>base_node_ptr_type</b></td></tr>
<tr class="separator:a3f47b700cc4d99ebfe7fbc3a0bf60bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efafe9fc82237012b0fdda53aeeb81f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8efafe9fc82237012b0fdda53aeeb81f"></a>
typedef const <br class="typebreak"/>
Internal::rbtree_node_base *&#160;</td><td class="memItemRight" valign="bottom"><b>const_base_node_ptr_type</b></td></tr>
<tr class="separator:a8efafe9fc82237012b0fdda53aeeb81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa94ef86562643a452e3817951bb01778"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa94ef86562643a452e3817951bb01778"></a>
typedef <a class="el" href="class_a_z_std_1_1rbtree.html">rbtree</a>&lt; Traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>this_type</b></td></tr>
<tr class="separator:aa94ef86562643a452e3817951bb01778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac3cac54f67e6800bc586f40e397eb8f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3cac54f67e6800bc586f40e397eb8f0"></a>
base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>create_node</b> (const value_type &amp;value)</td></tr>
<tr class="separator:ac3cac54f67e6800bc586f40e397eb8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d97fa8c51bc53e87839735d5c370c5b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d97fa8c51bc53e87839735d5c370c5b"></a>
template&lt;class... InputArguments&gt; </td></tr>
<tr class="memitem:a4d97fa8c51bc53e87839735d5c370c5b"><td class="memTemplItemLeft" align="right" valign="top">base_node_ptr_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_node</b> (InputArguments &amp;&amp;...arguments)</td></tr>
<tr class="separator:a4d97fa8c51bc53e87839735d5c370c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8320274828270cbbc282c8828db32b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8320274828270cbbc282c8828db32b5"></a>
AZ_FORCE_INLINE base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>clone_node</b> (base_node_ptr_type node)</td></tr>
<tr class="separator:af8320274828270cbbc282c8828db32b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2cfbdd6ed34441144e69270b5c16ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd2cfbdd6ed34441144e69270b5c16ae"></a>
base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>move_node</b> (base_node_ptr_type node)</td></tr>
<tr class="separator:abd2cfbdd6ed34441144e69270b5c16ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5add5053021f0755b7b93968fe447b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5add5053021f0755b7b93968fe447b0"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_node</b> (base_node_ptr_type parent, base_node_ptr_type newNode, base_node_ptr_type on_left=0, base_node_ptr_type on_right=0)</td></tr>
<tr class="separator:ab5add5053021f0755b7b93968fe447b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0faa07401d7ad47b18a556db3dd45c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf0faa07401d7ad47b18a556db3dd45c"></a>
<a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique_node</b> (base_node_ptr_type newNode)</td></tr>
<tr class="separator:adf0faa07401d7ad47b18a556db3dd45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1be0a30ff94cc897d2bb854229e582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd1be0a30ff94cc897d2bb854229e582"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal_node</b> (base_node_ptr_type newNode)</td></tr>
<tr class="separator:abd1be0a30ff94cc897d2bb854229e582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c98a02ecd984e328c5950355c879ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c98a02ecd984e328c5950355c879ac6"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_unique_node</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, base_node_ptr_type newNode)</td></tr>
<tr class="separator:a0c98a02ecd984e328c5950355c879ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9405ae8a888eadf03af9a2a648193bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9405ae8a888eadf03af9a2a648193bae"></a>
<a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_equal_node</b> (<a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a> insertPos, base_node_ptr_type newNode)</td></tr>
<tr class="separator:a9405ae8a888eadf03af9a2a648193bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a60f05d8596606d4c765fb75581166"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a60f05d8596606d4c765fb75581166"></a>
base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>copy</b> (base_node_ptr_type node, base_node_ptr_type parent)</td></tr>
<tr class="separator:ac1a60f05d8596606d4c765fb75581166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513e3db133ebbe3b5331176115ef1ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af513e3db133ebbe3b5331176115ef1ba"></a>
base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>move</b> (base_node_ptr_type node, base_node_ptr_type parent)</td></tr>
<tr class="separator:af513e3db133ebbe3b5331176115ef1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02777ab6caa1eccdd26eb18e5ecac208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02777ab6caa1eccdd26eb18e5ecac208"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (base_node_ptr_type node)</td></tr>
<tr class="separator:a02777ab6caa1eccdd26eb18e5ecac208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc38eebd2d5913da5789dea4be4d7b46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc38eebd2d5913da5789dea4be4d7b46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind</b> (base_node_ptr_type node)</td></tr>
<tr class="separator:abc38eebd2d5913da5789dea4be4d7b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f7d9c2bcc94e1d95d2193ce3b97846"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f7d9c2bcc94e1d95d2193ce3b97846"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>deallocate_node</b> (node_ptr_type node)</td></tr>
<tr class="separator:a49f7d9c2bcc94e1d95d2193ce3b97846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5087547d3e2ff86d1954852f6f587348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5087547d3e2ff86d1954852f6f587348"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_left</b> (base_node_ptr_type x)</td></tr>
<tr class="separator:a5087547d3e2ff86d1954852f6f587348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989da1a5046304e5b12f9cfe4e8fe2f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a989da1a5046304e5b12f9cfe4e8fe2f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate_right</b> (base_node_ptr_type x)</td></tr>
<tr class="separator:a989da1a5046304e5b12f9cfe4e8fe2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaced1cce419c82e5cfeed1ce16a8c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaced1cce419c82e5cfeed1ce16a8c6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rebalance</b> (base_node_ptr_type x)</td></tr>
<tr class="separator:acaced1cce419c82e5cfeed1ce16a8c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ade986f35bc02ea443be9ea642ad93e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ade986f35bc02ea443be9ea642ad93e"></a>
base_node_ptr_type&#160;</td><td class="memItemRight" valign="bottom"><b>rebalance_for_erase</b> (base_node_ptr_type z, base_node_ptr_type &amp;leftmost, base_node_ptr_type &amp;rightmost)</td></tr>
<tr class="separator:a8ade986f35bc02ea443be9ea642ad93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a73c58efd7c305c9a7db88943a2e31a16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c58efd7c305c9a7db88943a2e31a16"></a>
Internal::rbtree_node_base&#160;</td><td class="memItemRight" valign="bottom"><b>m_head</b></td></tr>
<tr class="separator:a73c58efd7c305c9a7db88943a2e31a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae875e4bc5957a5a90af54f9ccefee843"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae875e4bc5957a5a90af54f9ccefee843"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>m_numElements</b></td></tr>
<tr class="separator:ae875e4bc5957a5a90af54f9ccefee843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a496839e6ee0132073dde663409ef28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a496839e6ee0132073dde663409ef28"></a>
key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>m_keyEq</b></td></tr>
<tr class="separator:a1a496839e6ee0132073dde663409ef28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be18056bbd7915f400aafa65b04f37f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be18056bbd7915f400aafa65b04f37f"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>m_allocator</b></td></tr>
<tr class="separator:a4be18056bbd7915f400aafa65b04f37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Traits&gt;<br/>
class AZStd::rbtree&lt; Traits &gt;</h3>

<p>Generic red-black tree. Based on the STLport implementation. In addition to all <a class="el" href="namespace_a_z_std.html" title="AZ namespace needs to be closed in order to specialize the AZStd::hash struct for AddressTypeElement ...">AZStd</a> extensions and requirements, we use compressed node which saves about ~25% of the tree overhead. This is the base container used for <a class="el" href="class_a_z_std_1_1set.html">AZStd::set</a>,<a class="el" href="class_a_z_std_1_1multiset.html">AZStd::multiset</a>,<a class="el" href="class_a_z_std_1_1map.html">AZStd::map</a> and <a class="el" href="class_a_z_std_1_1multimap.html">AZStd::multimap</a>.</p>
<p>RedBlackTreeTest for examples.</p>
<p>Traits should have the following members typedef xxx key_type; typedef xxx key_equal; typedef xxx value_type; typedef xxx allocator_type; enum { has_multi_elements = true or false, is_dynamic = true or false, // true if we have fixed container. If we do so we will need to se fixed_num_buckets and fixed_num_elements. }</p>
<p>static inline const key_type&amp; key_from_value(const value_type&amp; value); </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa2a82f156a68dfe1b7553310c7b2e862"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::leak_and_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the container without deallocating any memory or calling any destructor. This function should be used when we need very quick tear down. Generally it's used for temporary vectors and we can just nuke them that way. In addition the provided <a class="el" href="_allocators.html">Allocators</a>, has leak and reset flag which will enable automatically this behavior. So this function should be used in special cases AZStdExamples. </p>
<dl class="section note"><dt>Note</dt><dd>This function is added to the vector for consistency. In the vector case we have only one allocation, and if the allocator allows memory leaks it can just leave deallocate function empty, which performance wise will be the same. For more complex containers this will make big difference. </dd></dl>

</div>
</div>
<a class="anchor" id="a60d84597279f45fd4fb59fb2e6adafc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for an element which matches the value of key and extracts it from the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> </p>
<dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type i.e a NodeHandle from an <a class="el" href="class_a_z_std_1_1unordered__map.html">unordered_map</a> can be used to insert a node into an <a class="el" href="class_a_z_std_1_1unordered__multimap.html">unordered_multimap</a>, but not a std::map </dd></dl>

</div>
</div>
<a class="anchor" id="ac71730ba5e3cac7386ad9c223ebf5209"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1rbtree__const__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element within the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> that is represented by the supplied iterator and extracts it </p>
<dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type </dd></dl>

</div>
</div>
<a class="anchor" id="a03292f2d5c86394b43db5755ec40431f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_insert_equal </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td> -&gt; <a class="el" href="class_a_z_std_1_1rbtree__iterator.html">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator pointing to the inserted element. If the nodeHandle is empty the end() iterator is returned </p>

</div>
</div>
<a class="anchor" id="ad679828b56edf29b1afcfabb6b6812a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class InsertReturnType , class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InsertReturnType <a class="el" href="class_a_z_std_1_1rbtree.html">AZStd::rbtree</a>&lt; Traits &gt;::node_handle_insert_unique </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an insert_return_type with the members initialized as follows: if nodeHandle is empty, inserted is false, position is end(), and node is empty. Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty. If the insertion failed, inserted is false, node has the previous value of nodeHandle, and position points to an element with a key equivalent to nodeHandle.key(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/std/containers/node_handle.h</li>
<li>Code/Framework/AzCore/AzCore/std/containers/rbtree.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 13 2023 22:57:23 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
