<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine AzCore API Reference: AZ::IO::StorageDriveWin Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">2107.1 (Developer Preview)</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z.html">AZ</a></li><li class="navelem"><a class="el" href="namespace_a_z_1_1_i_o.html">IO</a></li><li class="navelem"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html">StorageDriveWin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_1_1_i_o_1_1_storage_drive_win-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZ::IO::StorageDriveWin Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherits <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html">AZ::IO::StreamStackEntry</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_1_1_i_o_1_1_storage_drive_win_1_1_construction_options.html">ConstructionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1ad9d892eb3190c4e403179cb40c6643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a1ad9d892eb3190c4e403179cb40c6643">StorageDriveWin</a> (const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> &gt; &amp;drivePaths, u32 maxFileHandles, u32 maxMetaDataCacheEntries, size_t physicalSectorSize, size_t logicalSectorSize, u32 ioChannelCount, s32 overCommit, <a class="el" href="struct_a_z_1_1_i_o_1_1_storage_drive_win_1_1_construction_options.html">ConstructionOptions</a> options)</td></tr>
<tr class="separator:a1ad9d892eb3190c4e403179cb40c6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c014c2088a455194f85bc6d39eb9562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a5c014c2088a455194f85bc6d39eb9562">PrepareRequest</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> *request) override</td></tr>
<tr class="separator:a5c014c2088a455194f85bc6d39eb9562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6d9a21af852b4dd9479a0d2d693d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a3a6d9a21af852b4dd9479a0d2d693d96">QueueRequest</a> (<a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> *request) override</td></tr>
<tr class="separator:a3a6d9a21af852b4dd9479a0d2d693d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7118687ac5bb52c6f12567761604929c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a7118687ac5bb52c6f12567761604929c">ExecuteRequests</a> () override</td></tr>
<tr class="separator:a7118687ac5bb52c6f12567761604929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65ad53de1e6299fa6a50f24993809a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65ad53de1e6299fa6a50f24993809a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#ad65ad53de1e6299fa6a50f24993809a0">UpdateStatus</a> (<a class="el" href="struct_a_z_1_1_i_o_1_1_stream_stack_entry_1_1_status.html">Status</a> &amp;status) const override</td></tr>
<tr class="memdesc:ad65ad53de1e6299fa6a50f24993809a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a combined status update from all the nodes in the stack. <br/></td></tr>
<tr class="separator:ad65ad53de1e6299fa6a50f24993809a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1207c8abc102952f7128bdd292ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a11a1207c8abc102952f7128bdd292ff4">UpdateCompletionEstimates</a> (AZStd::chrono::steady_clock::time_point now, <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> * &gt; &amp;internalPending, <a class="el" href="class_a_z_std_1_1deque__iterator__impl.html">StreamerContext::PreparedQueue::iterator</a> pendingBegin, <a class="el" href="class_a_z_std_1_1deque__iterator__impl.html">StreamerContext::PreparedQueue::iterator</a> pendingEnd) override</td></tr>
<tr class="separator:a11a1207c8abc102952f7128bdd292ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778c0705ca44ad56a8318b49766a02a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_storage_drive_win.html#a2778c0705ca44ad56a8318b49766a02a">CollectStatistics</a> (<a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;statistics) const override</td></tr>
<tr class="separator:a2778c0705ca44ad56a8318b49766a02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html">AZ::IO::StreamStackEntry</a></td></tr>
<tr class="memitem:a64354e885cfbeb5a8b1144035a5ac2c5 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64354e885cfbeb5a8b1144035a5ac2c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StreamStackEntry</b> (<a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a> &amp;&amp;name)</td></tr>
<tr class="separator:a64354e885cfbeb5a8b1144035a5ac2c5 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb65f60c2ded5586339704482a67ccc inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bb65f60c2ded5586339704482a67ccc"></a>
virtual const <a class="el" href="class_a_z_std_1_1basic__string.html">AZStd::string</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#a8bb65f60c2ded5586339704482a67ccc">GetName</a> () const </td></tr>
<tr class="memdesc:a8bb65f60c2ded5586339704482a67ccc inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name that uniquely identifies this entry. <br/></td></tr>
<tr class="separator:a8bb65f60c2ded5586339704482a67ccc inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e8968a028ba4f0a5b04d6162587fed inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#a51e8968a028ba4f0a5b04d6162587fed">SetNext</a> (<a class="el" href="class_a_z_std_1_1shared__ptr.html">AZStd::shared_ptr</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html">StreamStackEntry</a> &gt; next)</td></tr>
<tr class="separator:a51e8968a028ba4f0a5b04d6162587fed inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a18ac8ce7fcd3b06217d14ae1e004f9 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_a_z_std_1_1shared__ptr.html">AZStd::shared_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html">StreamStackEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#a5a18ac8ce7fcd3b06217d14ae1e004f9">GetNext</a> () const </td></tr>
<tr class="separator:a5a18ac8ce7fcd3b06217d14ae1e004f9 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6fdc1ce65576fbd3dd01a766d9fc13 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6fdc1ce65576fbd3dd01a766d9fc13"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>SetContext</b> (<a class="el" href="class_a_z_1_1_i_o_1_1_streamer_context.html">StreamerContext</a> &amp;context)</td></tr>
<tr class="separator:aee6fdc1ce65576fbd3dd01a766d9fc13 inherit pub_methods_class_a_z_1_1_i_o_1_1_stream_stack_entry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ad9d892eb3190c4e403179cb40c6643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AZ::IO::StorageDriveWin::StorageDriveWin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_std_1_1basic__string__view.html">AZStd::string_view</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>drivePaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>maxFileHandles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>maxMetaDataCacheEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>physicalSectorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>logicalSectorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>ioChannelCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>overCommit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_z_1_1_i_o_1_1_storage_drive_win_1_1_construction_options.html">ConstructionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of a storage device that's optimized for use on Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drivePaths</td><td>The paths to the drives that are supported by this device. A single device can have multiple logical disks. </td></tr>
    <tr><td class="paramname">maxFileHandles</td><td>The maximum number of file handles that are cached. Only a small number are needed when running from archives, but it's recommended that a larger number are kept open when reading from loose files. </td></tr>
    <tr><td class="paramname">maxMetaDataCacheEntires</td><td>The maximum number of files to keep meta data, such as the file size, to cache. Only a small number are needed when running from archives, but it's recommended that a larger number are kept open when reading from loose files. </td></tr>
    <tr><td class="paramname">physicalSectorSize</td><td>The minimal sector size as instructed by the device. When unbuffered reads are used the output buffer needs to be aligned to this value. </td></tr>
    <tr><td class="paramname">logicalSectorSize</td><td>The minimal sector size as instructed by the device. When unbuffered reads are used the file size and read offset need to be aligned to this value. </td></tr>
    <tr><td class="paramname">ioChannelCount</td><td>The maximum number of requests that the <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation. ">IO</a> controller driving the device supports. This value will be capped by the maximum number of parallel requests that can be issued per thread. </td></tr>
    <tr><td class="paramname">overCommit</td><td>The number of additional slots that will be reported as available. This makes sure that there are always a few requests pending to avoid starvation. An over-commit that is too large can negatively impact the scheduler's ability to re-order requests for optimal read order. A negative value will under-commit and will avoid saturating the <a class="el" href="namespace_a_z_1_1_i_o.html" title="PathView implementation. ">IO</a> controller which can be needed if the drive is used by other applications. </td></tr>
    <tr><td class="paramname">options</td><td>Additional configuration options. See <a class="el" href="struct_a_z_1_1_i_o_1_1_storage_drive_win_1_1_construction_options.html">ConstructionOptions</a> for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2778c0705ca44ad56a8318b49766a02a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::IO::StorageDriveWin::CollectStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_statistic.html">Statistic</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>statistics</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Collect various statistics on this stack entry. These are for profiling and debugging purposes only. </p>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#af84afcf4ac999b94e62a0ec896ae47ee">AZ::IO::StreamStackEntry</a>.</p>

</div>
</div>
<a class="anchor" id="a7118687ac5bb52c6f12567761604929c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AZ::IO::StorageDriveWin::ExecuteRequests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes one or more queued requests. This is needed for synchronously executing requests, but asynchronous requests can already be running from the PrepareRequest call in which case this call is ignored. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a request was processed, otherwise false. </dd></dl>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#a6292292cf868569df827b4ef3907ea20">AZ::IO::StreamStackEntry</a>.</p>

</div>
</div>
<a class="anchor" id="a5c014c2088a455194f85bc6d39eb9562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::IO::StorageDriveWin::PrepareRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepare an external request for processing. This can include resolving file paths, create more specific internal requests, etc. The returned will be queued for further processing by QueueRequest and ExecuteRequest. </p>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#ab3ad36885f20fae669d0d2671fc51485">AZ::IO::StreamStackEntry</a>.</p>

</div>
</div>
<a class="anchor" id="a3a6d9a21af852b4dd9479a0d2d693d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::IO::StorageDriveWin::QueueRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queues a request to be executed at a later point when ExecuteRequests is called. This can include splitting up the request in more fine-grained steps. </p>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#a56ea0967d11f57190e65352dab84fc5f">AZ::IO::StreamStackEntry</a>.</p>

</div>
</div>
<a class="anchor" id="a11a1207c8abc102952f7128bdd292ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AZ::IO::StorageDriveWin::UpdateCompletionEstimates </td>
          <td>(</td>
          <td class="paramtype">AZStd::chrono::steady_clock::time_point&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1vector.html">AZStd::vector</a>&lt; <a class="el" href="class_a_z_1_1_i_o_1_1_file_request.html">FileRequest</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>internalPending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1deque__iterator__impl.html">StreamerContext::PreparedQueue::iterator</a>&#160;</td>
          <td class="paramname"><em>pendingBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_a_z_std_1_1deque__iterator__impl.html">StreamerContext::PreparedQueue::iterator</a>&#160;</td>
          <td class="paramname"><em>pendingEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the estimate of the time the requests will complete. This generally works by bubbling up the estimation and each stack entry adding it's additional overhead if any. When chaining this call, first call the next entry in the stack before adding the current entry's estimate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">now</td><td>The current time. This is captured once to avoid repeatedly querying the system clock. </td></tr>
    <tr><td class="paramname">internalPending</td><td>The requests that are pending in the stream stack. These are always estimated as coming after the queued requests. Because this call will go from the top of the stack to the bottom, but estimation is calculated from the bottom to the top, this list should be processed in reverse order. </td></tr>
    <tr><td class="paramname">pendingBegin</td><td>Iterator pointing to the start of the requests that are waiting for a processing slot in the stack. </td></tr>
    <tr><td class="paramname">pendingEnd</td><td>Iterator pointing to the end of the requests that are waiting for a processing slot in the stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_a_z_1_1_i_o_1_1_stream_stack_entry.html#addd1900209c97840ae43d19cdce667f7">AZ::IO::StreamStackEntry</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Code/Framework/AzCore/Platform/Windows/AzCore/IO/Streamer/StorageDrive_Windows.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 10 2023 22:40:42 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
