<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Open 3D Engine AzCore API Reference: AZStd::hash_table&lt; Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open 3D Engine AzCore API Reference
   &#160;<span id="projectnumber">2107.1 (Developer Preview)</span>
   </div>
   <div id="projectbrief">O3DE is an open-source, fully-featured, high-fidelity, modular 3D engine for building games and simulations, available to every industry.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_a_z_std.html">AZStd</a></li><li class="navelem"><a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_a_z_std_1_1hash__table-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AZStd::hash_table&lt; Traits &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;hash_table.h&gt;</code></p>

<p>Inherited by <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AddressType, Flags &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetContainer *, AZStd::shared_ptr&lt; AssetContainer &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetContainerKey, AZStd::weak_ptr&lt; AssetContainer &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetId, Asset&lt; AssetData &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetId, AssetData * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetType, AssetCatalog * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AssetType, AssetHandler * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::AZ::Name, AZStd::weak_ptr&lt; AZ::InstancePoolBase &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::AZ::Uuid, AZ::BehaviorClass * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::AZ::Uuid, AZStd::any &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::AZ::Uuid, AZStd::weak_ptr&lt; Internal::ReflectionFunctionRef &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Crc32, DataPatchUpgradeMap &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Crc32, ScriptProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Dom::PathEntry, Node &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::EntityId, AZ::DataPatch::FlagsMap &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Name::Hash, ScopedNameDataWrapper &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::u32, AZStd::intrusive_ptr&lt; UserSettings &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::GenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, CreateAnyFunc &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, Data::Asset&lt; AZ::ScriptAsset &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, Edit::ElementData &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, list&lt; EntryPoint &gt;::iterator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, LoadedScriptInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZ::Uuid, ScriptPropertyGenericClassMap * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorClass * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorEBus * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorEBus::VirtualProperty &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorEBusEventSender &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorMethod * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::BehaviorProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZ::Statistics::NamedRunningStatistic * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; AZStd::string, AZStd::chrono::steady_clock::time_point &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; BreakpointId, Breakpoint, AZStd::hash&lt; BreakpointId &gt;, AZStd::equal_to&lt; BreakpointId &gt;, OSStdAllocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; const AZ::BehaviorMethod *, AZStd::pair&lt; const AZ::BehaviorMethod *, const AZ::BehaviorClass * &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Data::Asset&lt; SliceAsset &gt;, SliceReference::SliceInstances &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, Entity * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, EntityId &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; EntityId, EntityInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; int, ScriptProperty * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; size_t, AZStd::vector&lt; const AZ::BehaviorParameter * &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StaticReflectionFunctionPtr, list&lt; EntryPoint &gt;::iterator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StatIdType, AZ::Statistics::NamedRunningStatistic * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StatisticalProfilerId, ProfilerInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; StringType, StringVector, AZStd::hash&lt; StringType &gt;, AZStd::equal_to&lt; StringType &gt;, StdAllocatorType &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; T, MapValuePair &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; uint32_t, AZStd::vector&lt; uint32_t &gt; &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; Uuid, ClassData &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__map.html">AZStd::unordered_map&lt; void *, AllocationInfo, AZStd::hash&lt; void * &gt;, AZStd::equal_to&lt; void * &gt;, AZStd::stateless_allocator &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AssetId, WaitForAsset * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::AZ::Crc32, AZ::AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Data::AssetId, AZ::Data::AssetContainer * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::IO::FileRequest *, Section &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Uuid, AZ::GenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__multimap.html">AZStd::unordered_multimap&lt; AZ::Uuid, AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::AZ::Uuid &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::Data::AZ::Data::AssetId &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::EntityId &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::ExplicitOverloadInfo &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZ::SerializeContext::PerModuleGenericClassInfo * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; AZStd::string &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; SerializeContext * &gt;</a>, <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; size_t &gt;</a>, and <a class="el" href="class_a_z_std_1_1unordered__set.html">AZStd::unordered_set&lt; SliceInstance &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae514a34963b5338c47eb74a171ac56d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae514a34963b5338c47eb74a171ac56d2"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><b>traits_type</b></td></tr>
<tr class="separator:ae514a34963b5338c47eb74a171ac56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467c545861ace831af9d7d4a12a1fe94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a467c545861ace831af9d7d4a12a1fe94"></a>
typedef Traits::key_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a467c545861ace831af9d7d4a12a1fe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d32532535e28543fddfe8fce6a768f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d32532535e28543fddfe8fce6a768f8"></a>
typedef Traits::key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_equal</b></td></tr>
<tr class="separator:a3d32532535e28543fddfe8fce6a768f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f90127c3c4d7f574c52c392eb5fa5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae75f90127c3c4d7f574c52c392eb5fa5"></a>
typedef Traits::hasher&#160;</td><td class="memItemRight" valign="bottom"><b>hasher</b></td></tr>
<tr class="separator:ae75f90127c3c4d7f574c52c392eb5fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95de53dafaeaa5220f52ec9599cf13a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa95de53dafaeaa5220f52ec9599cf13a"></a>
typedef Traits::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:aa95de53dafaeaa5220f52ec9599cf13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747afa8af49a1ccb3518fd05cf93cf6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a747afa8af49a1ccb3518fd05cf93cf6a"></a>
typedef storage_type::list_type&#160;</td><td class="memItemRight" valign="bottom"><b>list_type</b></td></tr>
<tr class="separator:a747afa8af49a1ccb3518fd05cf93cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788464389632245c454b6caf6eaa6db8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788464389632245c454b6caf6eaa6db8"></a>
typedef list_type::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a788464389632245c454b6caf6eaa6db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4039ad6cacd9efd7ef27a10bb5f30c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c4039ad6cacd9efd7ef27a10bb5f30c"></a>
typedef list_type::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:a7c4039ad6cacd9efd7ef27a10bb5f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556231c4b0a1bdcdb71769d5ba28019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6556231c4b0a1bdcdb71769d5ba28019"></a>
typedef list_type::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:a6556231c4b0a1bdcdb71769d5ba28019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40efb5994041f0270586d596df31d56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af40efb5994041f0270586d596df31d56"></a>
typedef list_type::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:af40efb5994041f0270586d596df31d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277ac2d4eb19cdd439aa042d7b204362"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a277ac2d4eb19cdd439aa042d7b204362"></a>
typedef list_type::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a277ac2d4eb19cdd439aa042d7b204362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39bff33131b5cf852e85ed099744a40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39bff33131b5cf852e85ed099744a40"></a>
typedef list_type::const_reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:af39bff33131b5cf852e85ed099744a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049dba5273781d99877c255904ae67a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae049dba5273781d99877c255904ae67a"></a>
typedef list_type::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ae049dba5273781d99877c255904ae67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835145080e2f46e25a44c9beadb1eeb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a835145080e2f46e25a44c9beadb1eeb4"></a>
typedef list_type::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a835145080e2f46e25a44c9beadb1eeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3094c12f8c0bb30eaf6dfe5fefb978"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3094c12f8c0bb30eaf6dfe5fefb978"></a>
typedef list_type::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr class="separator:a9d3094c12f8c0bb30eaf6dfe5fefb978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371bf82b01aa694db21a5959bbbc337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7371bf82b01aa694db21a5959bbbc337"></a>
typedef <br class="typebreak"/>
list_type::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr class="separator:a7371bf82b01aa694db21a5959bbbc337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574afbaeb075c01bf94666da2447eb03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a574afbaeb075c01bf94666da2447eb03"></a>
typedef list_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a574afbaeb075c01bf94666da2447eb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8506013b4d82d9bfce1cef40b4e20de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8506013b4d82d9bfce1cef40b4e20de"></a>
typedef iterator&#160;</td><td class="memItemRight" valign="bottom"><b>local_iterator</b></td></tr>
<tr class="separator:ae8506013b4d82d9bfce1cef40b4e20de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35525d9d989d082fd20a388665441640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35525d9d989d082fd20a388665441640"></a>
typedef const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_local_iterator</b></td></tr>
<tr class="separator:a35525d9d989d082fd20a388665441640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee3a86acb84086dd7b05ccbf4bbc14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeee3a86acb84086dd7b05ccbf4bbc14e"></a>
typedef <br class="typebreak"/>
storage_type::vector_value_type&#160;</td><td class="memItemRight" valign="bottom"><b>vector_value_type</b></td></tr>
<tr class="separator:aeee3a86acb84086dd7b05ccbf4bbc14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f95099f823cc0c453a1ed4ec8b540e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f95099f823cc0c453a1ed4ec8b540e"></a>
typedef storage_type::vector_type&#160;</td><td class="memItemRight" valign="bottom"><b>vector_type</b></td></tr>
<tr class="separator:a89f95099f823cc0c453a1ed4ec8b540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2751f8ec27a2ca3405deca04eb3906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada2751f8ec27a2ca3405deca04eb3906"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; iterator, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_iter_bool</b></td></tr>
<tr class="separator:ada2751f8ec27a2ca3405deca04eb3906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6992a794548538910a563ad64bc4cd54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6992a794548538910a563ad64bc4cd54"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; iterator, <br class="typebreak"/>
iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_iter_iter</b></td></tr>
<tr class="separator:a6992a794548538910a563ad64bc4cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79bb58f166aed277888fa3902dd558"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc79bb58f166aed277888fa3902dd558"></a>
typedef <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a><br class="typebreak"/>
&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pair_citer_citer</b></td></tr>
<tr class="separator:acc79bb58f166aed277888fa3902dd558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b769dd59dfc68faa76ee25a5a9f9ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72b769dd59dfc68faa76ee25a5a9f9ac"></a>
typedef list_type::node_type&#160;</td><td class="memItemRight" valign="bottom"><b>list_node_type</b></td></tr>
<tr class="separator:a72b769dd59dfc68faa76ee25a5a9f9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd92d9906545160fcbbb1b96047b862"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bd92d9906545160fcbbb1b96047b862"></a>
typedef vector_type::node_type&#160;</td><td class="memItemRight" valign="bottom"><b>vector_node_type</b></td></tr>
<tr class="separator:a3bd92d9906545160fcbbb1b96047b862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde678dd96d10403f86ecfdcfc66df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbde678dd96d10403f86ecfdcfc66df3"></a>
typedef <a class="el" href="class_a_z_std_1_1hash__node__destructor.html">hash_node_destructor</a><br class="typebreak"/>
&lt; allocator_type, <br class="typebreak"/>
list_node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_deleter</b></td></tr>
<tr class="separator:afbde678dd96d10403f86ecfdcfc66df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a25528d77f4b940fef0a60f47dc974210"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25528d77f4b940fef0a60f47dc974210"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const key_equal &amp;keyEqual, const allocator_type &amp;alloc=allocator_type())</td></tr>
<tr class="separator:a25528d77f4b940fef0a60f47dc974210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fedcbf9d44d80b0643902f4ad1902f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fedcbf9d44d80b0643902f4ad1902f5"></a>
AZ_FORCE_INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const value_type *first, const value_type *last, const hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const key_equal &amp;keyEqual, const allocator_type &amp;alloc)</td></tr>
<tr class="separator:a1fedcbf9d44d80b0643902f4ad1902f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610ef16e12172fe503e45564cb575212"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610ef16e12172fe503e45564cb575212"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;rhs)</td></tr>
<tr class="separator:a610ef16e12172fe503e45564cb575212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d87b0e9af0baa430e1542fcc795b99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d87b0e9af0baa430e1542fcc795b99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;rhs, const type_identity_t&lt; allocator_type &gt; &amp;alloc)</td></tr>
<tr class="separator:a51d87b0e9af0baa430e1542fcc795b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbf4a6911b77f8f0d2b1946daa7758b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dbf4a6911b77f8f0d2b1946daa7758b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a9dbf4a6911b77f8f0d2b1946daa7758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c425277974b194c567569f1bde34170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c425277974b194c567569f1bde34170"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>hash_table</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> &amp;&amp;rhs, const type_identity_t&lt; allocator_type &gt; &amp;alloc)</td></tr>
<tr class="separator:a5c425277974b194c567569f1bde34170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a1aff6ac992caebcdb11922182c721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89a1aff6ac992caebcdb11922182c721"></a>
<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a89a1aff6ac992caebcdb11922182c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec090e6bad022262648adcc041dd28c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec090e6bad022262648adcc041dd28c9"></a>
AZ_FORCE_INLINE <a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:aec090e6bad022262648adcc041dd28c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdf7be1fb3f1c02b24ffc9910a4cc7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accdf7be1fb3f1c02b24ffc9910a4cc7c"></a>
AZ_FORCE_INLINE iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:accdf7be1fb3f1c02b24ffc9910a4cc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3269dbbfeaf44823346212a81d4ce3cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3269dbbfeaf44823346212a81d4ce3cd"></a>
AZ_FORCE_INLINE const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:a3269dbbfeaf44823346212a81d4ce3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e9c17c5840a6ff2f6b6edae00d8b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a4e9c17c5840a6ff2f6b6edae00d8b8"></a>
AZ_FORCE_INLINE iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a0a4e9c17c5840a6ff2f6b6edae00d8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8d4f7caab466e889e267e57a5db54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54e8d4f7caab466e889e267e57a5db54"></a>
AZ_FORCE_INLINE const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a54e8d4f7caab466e889e267e57a5db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c2c7794ed33a862fc6639628d72cbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c2c7794ed33a862fc6639628d72cbd"></a>
AZ_FORCE_INLINE local_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (size_type bucket)</td></tr>
<tr class="separator:a17c2c7794ed33a862fc6639628d72cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae488cb0b0f1033e32b7f0b11fa5ed9a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae488cb0b0f1033e32b7f0b11fa5ed9a6"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_local_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (size_type bucket) const </td></tr>
<tr class="separator:ae488cb0b0f1033e32b7f0b11fa5ed9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b39ba9aa9def8e3eddfe6a3c1f2d7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80b39ba9aa9def8e3eddfe6a3c1f2d7d"></a>
AZ_FORCE_INLINE local_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (size_type bucket)</td></tr>
<tr class="separator:a80b39ba9aa9def8e3eddfe6a3c1f2d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ddbe631d4d6158a19ae59a84aac84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538ddbe631d4d6158a19ae59a84aac84"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_local_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (size_type bucket) const </td></tr>
<tr class="separator:a538ddbe631d4d6158a19ae59a84aac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5d1ac0f8a234512d7feb2c94ef146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd5d1ac0f8a234512d7feb2c94ef146"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> ()</td></tr>
<tr class="separator:a2bd5d1ac0f8a234512d7feb2c94ef146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a5888701efef5dfd023d990bc8716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f0a5888701efef5dfd023d990bc8716"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rbegin</b> () const </td></tr>
<tr class="separator:a0f0a5888701efef5dfd023d990bc8716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a07787db956ff915f26beb0cf1814a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02a07787db956ff915f26beb0cf1814a"></a>
AZ_FORCE_INLINE reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> ()</td></tr>
<tr class="separator:a02a07787db956ff915f26beb0cf1814a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935eb64c8a6e3ce7e91a1e6491f25b5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a935eb64c8a6e3ce7e91a1e6491f25b5b"></a>
AZ_FORCE_INLINE <br class="typebreak"/>
const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>rend</b> () const </td></tr>
<tr class="separator:a935eb64c8a6e3ce7e91a1e6491f25b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4521514455d67df3400b4ea985a8ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad4521514455d67df3400b4ea985a8ef"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const </td></tr>
<tr class="separator:aad4521514455d67df3400b4ea985a8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0baa3d5d6e59b141a8d3e3fc80173e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e0baa3d5d6e59b141a8d3e3fc80173e"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const </td></tr>
<tr class="separator:a7e0baa3d5d6e59b141a8d3e3fc80173e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27ea38c55bab100093d59c6a9c64121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27ea38c55bab100093d59c6a9c64121"></a>
AZ_FORCE_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const </td></tr>
<tr class="separator:ae27ea38c55bab100093d59c6a9c64121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4131dd3474f406e5aabccdf29b07930c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4131dd3474f406e5aabccdf29b07930c"></a>
AZ_FORCE_INLINE key_equal&#160;</td><td class="memItemRight" valign="bottom"><b>key_eq</b> () const </td></tr>
<tr class="separator:a4131dd3474f406e5aabccdf29b07930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae169e4da4769b5534f55ec9eb0fbab2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae169e4da4769b5534f55ec9eb0fbab2d"></a>
AZ_FORCE_INLINE hasher&#160;</td><td class="memItemRight" valign="bottom"><b>get_hasher</b> () const </td></tr>
<tr class="separator:ae169e4da4769b5534f55ec9eb0fbab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea2b9b65ef66c7185a9f04a4fcf015b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abea2b9b65ef66c7185a9f04a4fcf015b"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_count</b> () const </td></tr>
<tr class="separator:abea2b9b65ef66c7185a9f04a4fcf015b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426915703b8f75f37a572fa72aa2b4d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426915703b8f75f37a572fa72aa2b4d6"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>max_bucket_count</b> () const </td></tr>
<tr class="separator:a426915703b8f75f37a572fa72aa2b4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3497307694f8aa39306657adf899bd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3497307694f8aa39306657adf899bd3"></a>
AZ_FORCE_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket</b> (const key_type &amp;keyValue) const </td></tr>
<tr class="separator:ab3497307694f8aa39306657adf899bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b168f5f97792e743068a1141d37ffa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94b168f5f97792e743068a1141d37ffa"></a>
AZ_INLINE size_type&#160;</td><td class="memItemRight" valign="bottom"><b>bucket_size</b> (size_type bucket) const </td></tr>
<tr class="separator:a94b168f5f97792e743068a1141d37ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914d4c5c9d0de41e1c164068c7eeeac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8914d4c5c9d0de41e1c164068c7eeeac"></a>
AZ_FORCE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><b>load_factor</b> () const </td></tr>
<tr class="separator:a8914d4c5c9d0de41e1c164068c7eeeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4206dc433b7a5e5019cc07fbfd26d3e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4206dc433b7a5e5019cc07fbfd26d3e6"></a>
AZ_FORCE_INLINE float&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> () const </td></tr>
<tr class="separator:a4206dc433b7a5e5019cc07fbfd26d3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3025763a6046a11939cae44b12601584"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3025763a6046a11939cae44b12601584"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>max_load_factor</b> (float newMaxLoadFactor)</td></tr>
<tr class="separator:a3025763a6046a11939cae44b12601584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea173acf01b776f2ab8b10ce8a1724b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ea173acf01b776f2ab8b10ce8a1724b"></a>
AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const value_type &amp;value)</td></tr>
<tr class="separator:a0ea173acf01b776f2ab8b10ce8a1724b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f38d06ae5f7acec16447d0dcc6f33b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83f38d06ae5f7acec16447d0dcc6f33b"></a>
AZ_FORCE_INLINE iterator&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const_iterator, const value_type &amp;value)</td></tr>
<tr class="separator:a83f38d06ae5f7acec16447d0dcc6f33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac261f773e1e0fc93508f6f27c93aed5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac261f773e1e0fc93508f6f27c93aed5e"></a>
AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (value_type &amp;&amp;value)</td></tr>
<tr class="separator:ac261f773e1e0fc93508f6f27c93aed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1690cb4c0bce7500f92a38d557c66817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1690cb4c0bce7500f92a38d557c66817"></a>
AZ_FORCE_INLINE iterator&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (const_iterator, value_type &amp;&amp;value)</td></tr>
<tr class="separator:a1690cb4c0bce7500f92a38d557c66817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37092093965166265208e5cd5e4478a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a37092093965166265208e5cd5e4478a2"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a37092093965166265208e5cd5e4478a2"><td class="memTemplItemLeft" align="right" valign="top">AZ_FORCE_INLINE <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace</b> (Args &amp;&amp;...arguments)</td></tr>
<tr class="separator:a37092093965166265208e5cd5e4478a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0364c63006af918e205e56c05292be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0364c63006af918e205e56c05292be7"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (std::initializer_list&lt; value_type &gt; <a class="el" href="class_a_z_std_1_1list.html">list</a>)</td></tr>
<tr class="separator:ad0364c63006af918e205e56c05292be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bca1103af711aacb8e33d81b0684cfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5bca1103af711aacb8e33d81b0684cfb"></a>
template&lt;class Iterator &gt; </td></tr>
<tr class="memitem:a5bca1103af711aacb8e33d81b0684cfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert</b> (Iterator first, Iterator last) -&gt; enable_if_t&lt; input_iterator&lt; Iterator &gt; &amp;&amp;!is_convertible_v&lt; Iterator, size_type &gt;&gt;</td></tr>
<tr class="separator:a5bca1103af711aacb8e33d81b0684cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2974c3a566fc28e476b5fd53dfeff1"><td class="memTemplParams" colspan="2"><a class="anchor" id="add2974c3a566fc28e476b5fd53dfeff1"></a>
template&lt;class R &gt; </td></tr>
<tr class="memitem:add2974c3a566fc28e476b5fd53dfeff1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_range</b> (R &amp;&amp;rg) -&gt; enable_if_t&lt; Internal::container_compatible_range&lt; R, value_type &gt;&gt;</td></tr>
<tr class="separator:add2974c3a566fc28e476b5fd53dfeff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913b18ed7e1ce23870821f7338cfbc60"><td class="memTemplParams" colspan="2">template&lt;class InsertReturnType , class NodeHandle &gt; </td></tr>
<tr class="memitem:a913b18ed7e1ce23870821f7338cfbc60"><td class="memTemplItemLeft" align="right" valign="top">InsertReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a913b18ed7e1ce23870821f7338cfbc60">node_handle_insert</a> (NodeHandle &amp;&amp;nodeHandle)</td></tr>
<tr class="separator:a913b18ed7e1ce23870821f7338cfbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadedca14edd51d6d50b8df3fbec3207"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeadedca14edd51d6d50b8df3fbec3207"></a>
template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:aeadedca14edd51d6d50b8df3fbec3207"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>node_handle_insert</b> (const iterator hint, NodeHandle &amp;&amp;nodeHandle) -&gt; iterator</td></tr>
<tr class="separator:aeadedca14edd51d6d50b8df3fbec3207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade183bba58786aed7e4e15ba558319e7"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:ade183bba58786aed7e4e15ba558319e7"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#ade183bba58786aed7e4e15ba558319e7">node_handle_extract</a> (const key_type &amp;key)</td></tr>
<tr class="separator:ade183bba58786aed7e4e15ba558319e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cd5948dd03e79093495acf08f3fe11"><td class="memTemplParams" colspan="2">template&lt;class NodeHandle &gt; </td></tr>
<tr class="memitem:a24cd5948dd03e79093495acf08f3fe11"><td class="memTemplItemLeft" align="right" valign="top">NodeHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a24cd5948dd03e79093495acf08f3fe11">node_handle_extract</a> (const_iterator it)</td></tr>
<tr class="separator:a24cd5948dd03e79093495acf08f3fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83b30693e08ed57636936e4f36cf971"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad83b30693e08ed57636936e4f36cf971"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve</b> (size_type numBucketsMin)</td></tr>
<tr class="separator:ad83b30693e08ed57636936e4f36cf971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f73f89c7211d5a51a87385e68f45d5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f73f89c7211d5a51a87385e68f45d5f"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>rehash</b> (size_type numBucketsMin)</td></tr>
<tr class="separator:a2f73f89c7211d5a51a87385e68f45d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5984b69ce59743dd39017cc6c2cf8de7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5984b69ce59743dd39017cc6c2cf8de7"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const_iterator erasePos)</td></tr>
<tr class="separator:a5984b69ce59743dd39017cc6c2cf8de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab706c0a796aa15efe2720d9d87f1569a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab706c0a796aa15efe2720d9d87f1569a"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const key_type &amp;keyValue)</td></tr>
<tr class="separator:ab706c0a796aa15efe2720d9d87f1569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae383048ea06f963ddcdb6e8ceee1a0e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae383048ea06f963ddcdb6e8ceee1a0e3"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (const_iterator first, const_iterator last)</td></tr>
<tr class="separator:ae383048ea06f963ddcdb6e8ceee1a0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74518e73ea9323fbe8560f0efbbade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad74518e73ea9323fbe8560f0efbbade"></a>
AZ_FORCE_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:aad74518e73ea9323fbe8560f0efbbade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aace28282690535aaf6c1246e642ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2aace28282690535aaf6c1246e642ed"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:af2aace28282690535aaf6c1246e642ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, iterator &gt;</td></tr>
<tr class="separator:af2aace28282690535aaf6c1246e642ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133bded4409709c30916e86f81864f4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a133bded4409709c30916e86f81864f4c"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a133bded4409709c30916e86f81864f4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, const_iterator &gt;</td></tr>
<tr class="separator:a133bded4409709c30916e86f81864f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d0ba374297f52081564a6fc2923a91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a84d0ba374297f52081564a6fc2923a91"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a84d0ba374297f52081564a6fc2923a91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, bool &gt;</td></tr>
<tr class="separator:a84d0ba374297f52081564a6fc2923a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08505ee4aeb35c3815d27f42974c771d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a08505ee4aeb35c3815d27f42974c771d"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a08505ee4aeb35c3815d27f42974c771d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, size_type &gt;</td></tr>
<tr class="separator:a08505ee4aeb35c3815d27f42974c771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854458f591e96c7f6c0696b56c0c2440"><td class="memTemplParams" colspan="2"><a class="anchor" id="a854458f591e96c7f6c0696b56c0c2440"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a854458f591e96c7f6c0696b56c0c2440"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, iterator &gt;</td></tr>
<tr class="separator:a854458f591e96c7f6c0696b56c0c2440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a19d2e0a6bdb746a3111d4966d7cd587a"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, const_iterator &gt;</td></tr>
<tr class="separator:a19d2e0a6bdb746a3111d4966d7cd587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5181ca0d768afd2e162799029f936333"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5181ca0d768afd2e162799029f936333"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a5181ca0d768afd2e162799029f936333"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, iterator &gt;</td></tr>
<tr class="separator:a5181ca0d768afd2e162799029f936333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460d04c0be8f3015c29341be2658aa1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1460d04c0be8f3015c29341be2658aa1"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a1460d04c0be8f3015c29341be2658aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>upper_bound</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, const_iterator &gt;</td></tr>
<tr class="separator:a1460d04c0be8f3015c29341be2658aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9e25419aaa875549255f721975047a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1a9e25419aaa875549255f721975047a"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:a1a9e25419aaa875549255f721975047a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; iterator, iterator &gt;&gt;</td></tr>
<tr class="separator:a1a9e25419aaa875549255f721975047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229c60d7d4a6429cfd098007a8be331"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad229c60d7d4a6429cfd098007a8be331"></a>
template&lt;class ComparableToKey &gt; </td></tr>
<tr class="memitem:ad229c60d7d4a6429cfd098007a8be331"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>equal_range</b> (const ComparableToKey &amp;key) const -&gt; enable_if_t&lt;(Internal::is_transparent&lt; key_equal, ComparableToKey &gt;::value &amp;&amp;Internal::is_transparent&lt; hasher, ComparableToKey &gt;::value)||AZStd::is_convertible_v&lt; ComparableToKey, key_type &gt;, <a class="el" href="struct_a_z_std_1_1pair.html">AZStd::pair</a>&lt; const_iterator, const_iterator &gt;&gt;</td></tr>
<tr class="separator:ad229c60d7d4a6429cfd098007a8be331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c7d13da3d17a4cc6a3c1e5963e4747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91c7d13da3d17a4cc6a3c1e5963e4747"></a>
AZ_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_a_z_std_1_1hash__table.html">this_type</a> &amp;rhs)</td></tr>
<tr class="separator:a91c7d13da3d17a4cc6a3c1e5963e4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62695a2a82276f280e51fb4040264db9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62695a2a82276f280e51fb4040264db9"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:a62695a2a82276f280e51fb4040264db9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a></td></tr>
<tr class="separator:a62695a2a82276f280e51fb4040264db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0784a0596c049c14a3342435e5d9ce6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0784a0596c049c14a3342435e5d9ce6"></a>
template&lt;typename ComparableToKey , typename... Args&gt; </td></tr>
<tr class="memitem:ac0784a0596c049c14a3342435e5d9ce6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>try_emplace_transparent</b> (const_iterator, ComparableToKey &amp;&amp;key, Args &amp;&amp;...arguments) -&gt; iterator</td></tr>
<tr class="separator:ac0784a0596c049c14a3342435e5d9ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0943261c516aa550fd1b823d80c630d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0943261c516aa550fd1b823d80c630d7"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:a0943261c516aa550fd1b823d80c630d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; <a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a></td></tr>
<tr class="separator:a0943261c516aa550fd1b823d80c630d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad8c73fa8d4d750e35d23ab2f8c14fc1"></a>
template&lt;typename ComparableToKey , typename MappedType &gt; </td></tr>
<tr class="memitem:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_or_assign_transparent</b> (const_iterator, ComparableToKey &amp;&amp;key, MappedType &amp;&amp;value) -&gt; iterator</td></tr>
<tr class="separator:aad8c73fa8d4d750e35d23ab2f8c14fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extensions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="HashExtensions"></a></p>
</div></td></tr>
<tr class="memitem:aa5e31edaabc972c8859a3e5f9c56d921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5e31edaabc972c8859a3e5f9c56d921"></a>
AZ_FORCE_INLINE allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> ()</td></tr>
<tr class="separator:aa5e31edaabc972c8859a3e5f9c56d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6b563deb886cc54b0510ae85197e97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc6b563deb886cc54b0510ae85197e97"></a>
AZ_FORCE_INLINE const <br class="typebreak"/>
allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_allocator</b> () const </td></tr>
<tr class="separator:abc6b563deb886cc54b0510ae85197e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477e5431bd036dac3282df69a5535d6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a477e5431bd036dac3282df69a5535d6d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_allocator</b> (const allocator_type &amp;<a class="el" href="class_a_z_std_1_1allocator.html">allocator</a>)</td></tr>
<tr class="separator:a477e5431bd036dac3282df69a5535d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e6deb47d597669bd12691d8796f411"><td class="memTemplParams" colspan="2">template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:a78e6deb47d597669bd12691d8796f411"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a78e6deb47d597669bd12691d8796f411">find_as</a> (const ComparableToKey &amp;keyCmp, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq)</td></tr>
<tr class="separator:a78e6deb47d597669bd12691d8796f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83d6c00deab7f3c667221691e3a0933"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad83d6c00deab7f3c667221691e3a0933"></a>
template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:ad83d6c00deab7f3c667221691e3a0933"><td class="memTemplItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_as</b> (const ComparableToKey &amp;keyCmp, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq) const </td></tr>
<tr class="separator:ad83d6c00deab7f3c667221691e3a0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ff15a245dff93fa4a65b454df77b8b"><td class="memTemplParams" colspan="2">template&lt;class U , class Converter , class Hasher , class KeyEqual &gt; </td></tr>
<tr class="memitem:a36ff15a245dff93fa4a65b454df77b8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a36ff15a245dff93fa4a65b454df77b8b">insert_from</a> (const U &amp;userValue, const Converter &amp;convert, const Hasher &amp;<a class="el" href="struct_a_z_std_1_1hash.html">hash</a>, const KeyEqual &amp;keyEq)</td></tr>
<tr class="separator:a36ff15a245dff93fa4a65b454df77b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3842af92c51b8b88bea6d87f6be114"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3842af92c51b8b88bea6d87f6be114"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b> () const </td></tr>
<tr class="separator:a1e3842af92c51b8b88bea6d87f6be114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c5d80d6d40450c1e8e0b2c1fab5334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26c5d80d6d40450c1e8e0b2c1fab5334"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a26c5d80d6d40450c1e8e0b2c1fab5334">validate_iterator</a> (const iterator &amp;iter) const </td></tr>
<tr class="memdesc:a26c5d80d6d40450c1e8e0b2c1fab5334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates an iter iterator. Returns a combination of <a class="el" href="namespace_a_z_std.html#a77fc989e737c35ee90f2b8ef6f5e9b9c">iterator_status_flag</a>. <br/></td></tr>
<tr class="separator:a26c5d80d6d40450c1e8e0b2c1fab5334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c07d470f6c2d1c43e86bdd7bf92c504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c07d470f6c2d1c43e86bdd7bf92c504"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>validate_iterator</b> (const const_iterator &amp;iter) const </td></tr>
<tr class="separator:a9c07d470f6c2d1c43e86bdd7bf92c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21df90689557c5518c0d1d41c51c21d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_z_std_1_1hash__table.html#a21df90689557c5518c0d1d41c51c21d5">leak_and_reset</a> ()</td></tr>
<tr class="separator:a21df90689557c5518c0d1d41c51c21d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Traits&gt;<br/>
class AZStd::hash_table&lt; Traits &gt;</h3>

<p>Hash table is internal container used as a base class for all unordered associative containers. It provides functionality for the unordered container in CTR1. (6.3.4). In addition we introduce the following <a class="el" href="class_a_z_std_1_1hash__table.html#HashExtensions">extensions</a>.</p>
<p>Traits should have the following members typedef xxx key_type; typedef xxx key_equal; typedef xxx hasher; typedef xxx value_type; typedef xxx allocator_type; enum { max_load_factor = xxx, // What should the max load factor before we grow the map. Load factor is the average num of elements per bucket. min_buckets = xxx, // Min num of buckets to be allocated. has_multi_elements = true or false, is_dynamic = true or false, // true if we have fixed container. If we do so we will need to se fixed_num_buckets and fixed_num_elements. fixed_num_buckets = xxx, // Number of buckets to pre-allocate. For hashing purposes it will be good to be a prime number. We we get better bucket distribution. // It should be aprox. 1/3 - 1/4 (max_load_factor 3 or 4) of the number of elements, otherwise we will have too much liear searches. fixed_num_elements = xxx, // Number of elements to pre-allocate. }</p>
<p>static inline key_type key_from_value(const value_type&amp; value);</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a78e6deb47d597669bd12691d8796f411"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits&gt; </div>
<div class="memtemplate">
template&lt;class ComparableToKey , class Hasher , class KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::find_as </td>
          <td>(</td>
          <td class="paramtype">const ComparableToKey &amp;&#160;</td>
          <td class="paramname"><em>keyCmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>keyEq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is similar to lazy_find in this paper C14IDEAS. The idea is to be able to customize the search. For non key_type objects. </p>

</div>
</div>
<a class="anchor" id="a36ff15a245dff93fa4a65b454df77b8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits&gt; </div>
<div class="memtemplate">
template&lt;class U , class Converter , class Hasher , class KeyEqual &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_z_std_1_1pair.html">pair_iter_bool</a> <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::insert_from </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>userValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Converter &amp;&#160;</td>
          <td class="paramname"><em>convert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Hasher &amp;&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyEqual &amp;&#160;</td>
          <td class="paramname"><em>keyEq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts from a value and converter object. Converter object has the following interface struct MyConverter { typedef Map::key_type or CompareableToKeyType key_type; const key_type&amp; to_key(const&amp; MyValue) const; Map::value_type to_value(const&amp; MyValue) const; } This allow us to convert any "userValue" (U parameter) to a key, check if we can add it to the list, if so, we call to_value function to create (to_key(userValue), to_value(userValue)) and add it to the hash table. This is similar to lazy_insert in this paper C14IDEAS. There is an example why it's beneficial, you can check AZStdExamples. The main idea is that you don't to create unnecessary expensive temporaries. </p>

</div>
</div>
<a class="anchor" id="a21df90689557c5518c0d1d41c51c21d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::leak_and_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the container without deallocating any memory or calling any destructor. This function should be used when we need very quick tear down. Generally it's used for temporary vectors and we can just nuke them that way. In addition the provided <a class="el" href="_allocators.html">Allocators</a>, has leak and reset flag which will enable automatically this behavior. So this function should be used in special cases AZStdExamples. </p>
<dl class="section note"><dt>Note</dt><dd>This function is added to the vector for consistency. In the vector case we have only one allocation, and if the allocator allows memory leaks it can just leave deallocate function empty, which performance wise will be the same. For more complex containers this will make big difference. </dd></dl>

</div>
</div>
<a class="anchor" id="ade183bba58786aed7e4e15ba558319e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for an element which matches the value of key and extracts it from the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> </p>
<dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type i.e a NodeHandle from an <a class="el" href="class_a_z_std_1_1unordered__map.html">unordered_map</a> can be used to insert a node into an <a class="el" href="class_a_z_std_1_1unordered__multimap.html">unordered_multimap</a>, but not a std::map </dd></dl>

</div>
</div>
<a class="anchor" id="a24cd5948dd03e79093495acf08f3fe11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class NodeHandle &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeHandle <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_extract </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds an element within the <a class="el" href="class_a_z_std_1_1hash__table.html">hash_table</a> that is represented by the supplied iterator and extracts it </p>
<dl class="section return"><dt>Returns</dt><dd>A NodeHandle which can be used to insert the an element between unique and non-unique containers of the same type </dd></dl>

</div>
</div>
<a class="anchor" id="a913b18ed7e1ce23870821f7338cfbc60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Traits &gt; </div>
<div class="memtemplate">
template&lt;class InsertReturnType , class NodeHandle &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">InsertReturnType <a class="el" href="class_a_z_std_1_1hash__table.html">AZStd::hash_table</a>&lt; Traits &gt;::node_handle_insert </td>
          <td>(</td>
          <td class="paramtype">NodeHandle &amp;&amp;&#160;</td>
          <td class="paramname"><em>nodeHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an insert_return_type with the members initialized as follows: if nh is empty, inserted is false, position is end(), and node is empty. Otherwise if the insertion took place, inserted is true, position points to the inserted element, and node is empty. If the insertion failed, inserted is false, node has the previous value of nh, and position points to an element with a key equivalent to nh.key(). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Code/Framework/AzCore/AzCore/std/containers/node_handle.h</li>
<li>Code/Framework/AzCore/AzCore/std/hash_table.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Mar 10 2023 22:41:05 for Open 3D Engine AzCore API Reference by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
